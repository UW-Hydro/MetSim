"""
TODO
"""

import numpy as np
import pandas as pd 

from metsim.configuration import PARAMS as params
from metsim.configuration import CONSTS as consts
from metsim.configuration import OPTIONS as options

class Forcing(object):
    """
    TODO
    """
    
    def __init__(self, met_data: pd.DataFrame, params: dict):
        """
        Initialize the forcing object.

        Args:
            met_data: A dataframe containing given forcings.
                      For example, these could be read in 
                      from a file or generated by some other
                      code.
            params: A dictionary of parameters about the site
                    being analyzed.
        """
        # Update the configuration
        import metsim.configuration
        metsim.configuration.update(params)
        self._validate_inputs(met_data, params)
        self.met_data = met_data
        self.solar_geom = self._calc_solar_geom()
        

    def generate_met_forcings(self, forcing_method):
        """
        Generate the required forcings.  In the future this 
        should have some added functionality so that it can
        pick out the required forcings if there are more than
        the minimum requirement given.  
        """
        # TODO: This is a shortcut, but works for the default
        #       situation
        forcing_method.run(self.met_data, self.solar_geom)


    def disaggregate(self):
        """
        Converts all of the daily variables to hourly
        """
        import metsim.disaggregate as disagg
        self.met_data = disagg.disaggregate(self.met_data, self.solar_geom) 


    def set_dates(self, dates: pd.DatetimeIndex):
        """ Set the index of the met_data to certain dates """
        self.met_data.set_index(dates, inplace=True)
        self.add_data("day_of_year", dates.dayofyear)


    def add_data(self, key, data):
        """ Add some data to the met_data with a given key """
        self.met_data[key] = data


    def _validate_inputs(self, met_data: pd.DataFrame, params: dict):
        """ Make sure all the required information has been input """
        met_data['wind']
        met_data['precip']
        met_data['t_min']
        met_data['t_max']
        params['lat']
        params['lon']


    def _calc_solar_geom(self):
        """
        Flat earth assumption
        """
        tt_max0 = np.zeros(366)
        daylength = np.zeros(366)
        flat_potrad = np.zeros(366) 
        slope_potrad = np.zeros(366) 
        trans = np.power(params['TBASE'], np.power((1.0-(consts['LR_STD'] * params['site_elev'])/consts['T_STD']),
                     (consts['G_STD'] / (consts['LR_STD'] * (consts['R'] / consts['MA'])))))
        lat    = np.clip(params['site_lat']*consts['RADPERDEG'], -np.pi/2., np.pi/2.0)
        coslat = np.cos(lat)
        sinlat = np.sin(lat)
        cosslp = np.cos(params['site_slope']  * consts['RADPERDEG'])
        sinslp = np.sin(params['site_slope']  * consts['RADPERDEG'])
        cosasp = np.cos(params['site_aspect'] * consts['RADPERDEG'])
        sinasp = np.sin(params['site_aspect'] * consts['RADPERDEG'])
        coszeh = np.cos(np.pi / 2.-(params['site_east_horiz'] * consts['RADPERDEG']))
        coszwh = np.cos(np.pi / 2.-(params['site_west_horiz'] * consts['RADPERDEG']))
        dt     = consts['SRADDT']  
        dh     = dt / consts['SECPERRAD'] 
    
        tiny_step_per_day = 86400 / consts['SRADDT']
        tiny_rad_fract    = np.zeros(shape=(366, tiny_step_per_day), dtype=np.float64)
        for i in range(365):
            decl = consts['MINDECL'] * np.cos((i + consts['DAYSOFF']) * consts['RADPERDAY'])
            cosdecl = np.cos(decl)
            sindecl = np.sin(decl)
            bsg1 = -sinslp * sinasp * cosdecl
            bsg2 = (-cosasp * sinslp * sinlat + cosslp * coslat) * cosdecl
            bsg3 = (cosasp * sinslp * coslat + cosslp * sinlat) * sindecl
            cosegeom = coslat * cosdecl
            sinegeom = sinlat * sindecl
            coshss = np.clip(-sinegeom / cosegeom, -1, 1)
            hss = np.cos(coshss)  
            daylength[i] = np.maximum(2.0 * hss * consts['SECPERRAD'], 86400)
            dir_beam_topa = 1368.0 + 45.5 * np.sin((2.0 * np.pi * i / 365.25) + 1.7) * dt
            sum_trans = 0.
            sum_flat_potrad = 0.
            sum_slope_potrad = 0.
            for h in np.arange(-hss, hss, dh):
                cosh = np.cos(h)
                sinh = np.sin(h)
                cza = cosegeom * cosh + sinegeom
                cbsa = sinh * bsg1 + cosh * bsg2 + bsg3
                if (cza > 0.):
                    dir_flat_topa = dir_beam_topa * cza
                    am = 1.0 / (cza + 0.0000001)
                    if (am > 2.9):
                        ami = min(max(int((np.cos(cza) / consts['RADPERDEG'])) - 69,0),20)
                        am = consts['OPTAM'][ami]
                    sum_trans += np.power(trans, am) * dir_flat_topa
                    sum_flat_potrad += dir_flat_topa
                    # FIXME: This is a long conditional
                    if ((h < 0. and cza > coszeh and cbsa > 0.) or
                            (h >= 0. and cza > coszwh and cbsa > 0.)):
                        sum_slope_potrad += dir_beam_topa * cbsa
                else:
                    dir_flat_topa = -1
                tinystep = np.clip(((12 * 3600 + h * consts['SECPERRAD'])/dt), 0, tiny_step_per_day - 1)
                tiny_rad_fract[i, tinystep] = max(dir_flat_topa, 0)
            if daylength[i] and sum_flat_potrad > 0:
                tiny_rad_fract[i] /= sum_flat_potrad
            if daylength[i]:
                tt_max0[i] = sum_trans / sum_flat_potrad
                flat_potrad[i] = sum_flat_potrad / daylength[i]
                slope_potrad[i] = sum_slope_potrad / daylength[i]
            else:
                tt_max0[i] = 0.
                flat_potrad[i] = 0.
                slope_potrad[i] = 0.
        tt_max0[365] = tt_max0[364]
        flat_potrad[365] = flat_potrad[364]
        slope_potrad[365] = slope_potrad[364]
        daylength[365] = daylength[364]
        tiny_rad_fract[365] = tiny_rad_fract[364]
        solar_geom = {"tt_max0" : tt_max0,
                      "flat_potrad" : flat_potrad,
                      "slope_potrad" : slope_potrad,
                      "daylength" : daylength,
                      "tiny_rad_fract" : tiny_rad_fract}
        return solar_geom 
    
    
